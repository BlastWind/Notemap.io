import React, { Component } from "react";
import * as d3 from "d3";
import { select, event } from "d3-selection";
import "./GraphEditor.css";
import "d3-selection-multi";
import link from "./svgs/network.svg";
import link_purple from "./svgs/network_purple.svg";
import add from "./svgs/thin-add-button.svg";
import focus from "./svgs/crosshair.svg";

import PageContainer from "./PageContainer.js";

// set up svg for D3
const initialNodes = [
  {
    id: 0,
    width: 50,
    height: 40,
    text: ["here"],
    opacity: 1,
    x: 750,
    y: 200
  },
  {
    id: 1,
    width: 50,
    height: 40,
    text: ["start"],
    opacity: 1,
    x: 600,
    y: 200
  },
  {
    id: 2,
    width: 50,
    height: 40,
    text: ["hi"],
    x: 300,
    y: 200
  }
];
const initialLinks = [
  {
    source: initialNodes[1],
    target: initialNodes[2]
  },

  {
    source: initialNodes[2],
    target: initialNodes[0]
  }
];

class GraphEditor extends Component {
  constructor(props) {
    super(props);

    this.nodes = initialNodes;
    this.links = initialLinks;
    this.lastNodeId = 2;

    this.selectedNode = null;
    this.selectedLink = null;
    this.mousedownLink = null;
    this.mousedownNode = null;
    this.mouseupNode = null;

    this.linkModeActivated = false;
    this.isCentering = false;

    this.force = null;
    this.startText = null;
    this.history = [
      {
        nodes: [...initialNodes],
        links: [...initialLinks]
      }
    ];
    this.txtHistory = [];
    this.historyStep = 0;
    this.previousTransform = null;
  }

  updateEntire() {
    d3.selectAll("svg").remove("*");
    d3.selectAll(".GraphEditorContainer")

      .selectAll("svg")
      .remove("*");

    this.force.stop();
    this.componentDidMount();
    this.force.restart();
  }

  componentDidMount() {
    var that = this;

    var GraphEditor = d3.select("div#editorsContainer");
    var svgContainer = GraphEditor.append("div").attr(
      "class",
      "GraphEditorContainer"
    );

    //d3.select("#addPic").on("click", addNewNode);
    d3.select("#focusPic").on("click", huh);
    d3.select("#linkPic").on("click", function() {
      var current = d3.select(this);
      if (current.attr("src") === link_purple) {
        that.linkModeActivated = false;
        current.attr("src", link);
      } else {
        current.attr("src", link_purple);
        that.linkModeActivated = true;
      }
    });

    const colors = d3.scaleOrdinal(d3.schemeCategory10);

    that.force = d3
      .forceSimulation()
      .force("link", d3.forceLink().id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-5))

      .on("tick", tick);

    const svg = d3
      .select(".GraphEditorContainer")
      .append("svg")

      .style("width", window.innerWidth * 0.75)
      .attr("height", window.innerHeight)
      .style("float", "left");
    // define arrow markers for graph that.link
    svg
      .append("svg:defs")
      .append("svg:marker")
      .attr("id", "end-arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 6)
      .attr("markerWidth", 3)
      .attr("markerHeight", 3)
      .attr("orient", "auto")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#000");

    svg
      .append("svg:defs")
      .append("svg:marker")
      .attr("id", "start-arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 4)
      .attr("markerWidth", 3)
      .attr("markerHeight", 3)
      .attr("orient", "auto")
      .append("svg:path")
      .attr("d", "M10,-5L0,0L10,5")
      .attr("fill", "#000");

    // line displayed when dragging new nodes

    const drag = d3
      .drag()
      .filter(function() {
        if (that.linkModeActivated) {
          svg
            .on(".zoom", null)
            .on("mousedown.zoom", null)
            .on("touchstart.zoom", null)
            .on("touchmove.zoom", null)
            .on("touchend.zoom", null);
        }

        return !that.linkModeActivated && !d3.event.ctrlKey;
      })
      .on("start", d => {
        if (!d3.event.active) that.force.alphaTarget(0.3).restart();

        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", d => {
        if (!that.linkModeActivated) {
          d.fx = d3.event.x;
          d.fy = d3.event.y;
        } else {
          dragLine
            .classed("hidden", false)
            .style("marker-end", "url(#end-arrow)");
          dragLine.attr(
            "d",
            `M${that.mousedownNode.x + that.mousedownNode.width / 2},${that
              .mousedownNode.y +
              that.mousedownNode.height / 2}L${d3.mouse(svg.node())[0]},${
              d3.mouse(svg.node())[1]
            }`
          );
        }
      })
      .on("end", d => {
        if (that.linkModeActivated) {
          dragLine.classed("hidden", true);
        }
        if (!d3.event.active) that.force.alphaTarget(0);

        d.fx = null;
        d.fy = null;
        resetMouseVars();
      });
    var container = svg
      .on("mousedown", mousedown)
      .on("mousemove", mousemove)
      .on("mouseup", mouseup)
      .on("keydown", keydown)
      .on("click", click)

      .append("svg:g")
      .attr("class", "gContainer")
      .attrs({
        //TODO
        //transform: previous transform
        transform: that.previousTransform ? that.previousTransform : null
      });

    const dragLine = container
      .append("svg:path")
      .attr("class", "link dragline hidden")
      .attr("d", "M0,0L0,0")
      .classed("hidden", true);

    // handles to link and node element groups
    let path = container.append("svg:g").selectAll("path");
    let circle = container
      .append("svg:g")
      .selectAll("g")
      .attr("class", "rectTextGroup");
    let textBox = container.append("foreignObject");
    // app starts here
    var zoom = d3.zoom().on("zoom", function() {
      container.attr("transform", d3.event.transform);
    });

    svg.call(zoom).on("dblclick.zoom", null);

    if (that.previousTransform) {
      var arr = that.previousTransform.split("(");

      var translate = arr[1].split(")")[0],
        scale = arr[2].split(")")[0];

      svg.call(
        zoom.transform,
        d3.zoomIdentity
          .translate(
            translate.substring(0, translate.indexOf(",")),
            translate.substring(translate.indexOf(",") + 1)
          )
          .scale(scale)
      );
    }

    //.attr("transform", that.previousTransform);

    d3.select(window)
      .on("keydown", keydown)
      .on("keyup", keyup)
      .on("resize", resize);
    restart();

    function resetMouseVars() {
      that.mousedownNode = null;
      that.mouseupNode = null;
      that.mousedownLink = null;
    }
    // update force layout (called automatically each iteration)
    function tick() {
      // draw directed edges with proper padding from node centers

      path.attr("d", d => {
        //console.log("force", that.force.nodes());
        var dy = d.target.y - d.source.y;
        var dx = d.target.x - d.source.x;
        var theta = Math.atan2(-dy, dx);
        theta += Math.PI;
        let angle = (theta * Math.PI) / 180;
        const shiftXBy = 0;
        return `M${d.source.x + d.source.width / 2},${d.source.y +
          d.source.height / 2}L${d.target.x + d.target.width / 2},${d.target.y +
          d.target.height / 2}`;
      });

      circle.attr("transform", d => {
        if (that.textInputCircle)
          if (d.id === that.textInputCircle.id) {
            that.textInputCircle.x = d.x;
            that.textInputCircle.y = d.y;
          }

        return `translate(${d.x},${d.y})`;
      });

      if (textBox.attr("x")) {
        //warning, chance 25 to something else, this is calculated with 50 / 2
        textBox
          .attr("x", that.textInputCircle.x + 25)
          .attr("y", that.textInputCircle.y);
      }
    }
    // update graph (called when needed)
    function storeToHistory() {
      that.history = that.history.slice(0, that.historyStep + 1);

      var newStep = {
        nodes: [...that.nodes],
        links: [...that.links],
        nodeToChangeID: that.nodeToChange ? that.nodeToChange.id : -1,
        texts: {
          undoTo: that.startText,
          redoTo: that.nodeToChange ? that.nodeToChange.text : null
        }
      };
      that.history = that.history.concat([newStep]);

      that.historyStep += 1;
      //console.log("new step", newStep);
      console.log("entire history", that.history, "step: ", that.historyStep);
    }

    function restart() {
      // path (link) group

      d3.selectAll("rect.node").remove();
      d3.selectAll("text").remove();
      //console.log("restarted");
      //JOIN DATA
      path = path.data(that.links);

      // update existing that.links
      path
        .classed("selected", d => d === that.selectedLink)
        .style("marker-end", "url(#end-arrow)");

      // EXIT
      path.exit().remove();

      // UPDATE
      path = path
        .enter()
        .append("svg:path")
        .attr("class", "link")
        .classed("selected", d => d === that.selectedLink)
        .style("marker-end", "url(#end-arrow)")
        .on("mousedown", d => {
          if (d3.event.ctrlKey || that.linkModeActivated) return;

          // select link
          that.mousedownLink = d;
          that.selectedLink =
            that.mousedownLink === that.selectedLink
              ? null
              : that.mousedownLink;
          that.selectedNode = null;
          restart();
        })
        .merge(path);

      // bind data
      // svg => g => g => {circle, text}
      let g = circle.data(that.nodes, d => d.id);
      g.exit().remove();
      g = g
        .enter()
        .append("svg:g")
        .attr("class", "rectTextGroup")
        .merge(g)
        .call(drag);

      g.on("mouseup", function() {});

      //d3.selectAll("rect").remove();
      //d3.selectAll("text").remove();

      var rect = g.append("svg:rect");

      //console.log("rect", rect);

      //render text's text so we have bboxWidth,

      var textContainers = g.append("svg:g").attr("class", "textContainer");

      textContainers

        .attr("opacity", d => d.opacity)
        //.attr("text-anchor", "middle")
        .attr("dy", function(d) {
          var nwords = d.text.length;
          return "-" + (nwords - 1) * 12;
        })
        .each(function(d, ind) {
          //after appending the tspan elements
          //we get access to widthArray
          var nwords = d.text.length;
          for (var i = 0; i < nwords; i++) {
            var tspan = d3
              .select(this)
              .append("text")
              .html(function(d) {
                var a = d.text[i];
                while (a.includes(" ")) {
                  a = a.replace(" ", "&nbsp;");
                }
                return a;
              });

            tspan.call(() => {
              var bboxWidth = d3
                .select(this)
                .node()
                .getBBox().width;

              that.textInputCircle = {
                ...that.textInputCircle,
                goodX: (d.width - bboxWidth) / 2
              };
            });

            if (i > 0) tspan.attr("y", 15 * i);
          }

          var eachTextHeight = d3
            .select(this)
            .select("text")
            .node()
            .getBBox().height;
          var textGroup = d3.select(this).selectAll("text");
          var widthArray = [];
          textGroup.each(function() {
            widthArray.push(
              d3
                .select(this)
                .node()
                .getBBox().width
            );
          });
          d.width = Math.max(...widthArray) + 50;

          d.height = d.text.length * eachTextHeight + 25;

          //console.log("width array for text group num " + ind, widthArray);
        })
        .style("transform", function(d) {
          var bboxWidth = d3
            .select(this)
            .node()
            .getBBox().width;

          var bboxHeight = d3
            .select(this)
            .node()
            .getBBox().height;
          var toShiftX = 25;
          var toShiftY = (d.height - bboxHeight) / 2 + 12.5;
          return "translate(" + toShiftX + "px, " + toShiftY + "px)";
        });

      rect
        .attr("class", "node")
        .attr("rx", 6)
        .attr("ry", 6)
        .attrs({
          width: d => d.width,
          height: d => d.height
        })
        .style("fill", d =>
          d === that.selectedNode
            ? d3
                .rgb(colors(d.id))
                .brighter()
                .toString()
            : colors(d.id)
        )
        .style("stroke", "black")
        .on("click", function(d) {
          if (
            d3.select(this).style("fill") === d3.rgb(colors(d.id)).toString()
          ) {
            d3.select(this).style("fill", d =>
              d3
                .rgb(colors(d.id))
                .brighter()
                .toString()
            );
          } else {
            that.selectedNode = null;
            d3.select(this).style("fill", d => d3.rgb(colors(d.id)).toString());
          }
        })
        .on("dblclick", function(d) {
          svg.on(".zoom", null);

          that.startText = d.text;
          that.nodes.map(eachNode => {
            if (eachNode.id === d.id) {
              eachNode.opacity = 0;
              restart();
            }
          });
          that.textInputCircle = d;
          // warning: please replac window.innerWidth
          textBox = textBox
            .attr("x", function(d) {
              return 10;
            })
            .attr("y", d.y)
            .attr("width", window.innerWidth / 2)
            .attr("height", window.innerHeight);
          var paragraph = textBox
            .append("xhtml:p")
            .html(function() {
              function textArrToHTML(textArr) {
                //["hi my name is", "andrew chen"] to <p>hi my name is<br>andrew chen</p>
                var initialHTML = "<p>";
                for (var i = 0; i < textArr.length; i++) {
                  if (textArr[i] === "") {
                    initialHTML += "<br>";
                  } else initialHTML += textArr[i];

                  if (i !== textArr.length - 1 && textArr[i] !== "") {
                    initialHTML += "<br>";
                  }
                }
                return initialHTML + "</p>";
              }
              var textArr = d.text;
              var html = textArrToHTML(textArr);

              return html;
            })
            .attr("contentEditable", "true")
            //warning: changing to window.innerWidth to prevent some dude spamming shift enter or extra long node?
            .attr("width", window.innerWidth / 2)
            .style("width", window.innerWidth / 2)
            .style("outline", 0)
            .style("font", "12px sans-serif")
            .style("display", "block");

          paragraph
            .on("blur", function() {
              svg.call(
                d3
                  .zoom()
                  .scaleExtent([0.1, 4])
                  .on("zoom", function() {
                    container.attr("transform", d3.event.transform);
                  })
              );
              d3.selectAll("foreignObject").remove();
              textBox = container.append("foreignObject");

              that.nodes.map(eachNode => {
                if (eachNode.id === that.textInputCircle.id) {
                  eachNode.opacity = 1;
                  restart();
                }
              });

              var oldNodes = that.history[that.historyStep].nodes;

              var matchedNode = oldNodes.filter(eachNode => {
                return eachNode.id === d.id;
              });

              //TODO: if text isn't the same or the node is brand new, store to history
              //on add new node, notNewNode is false
              //on dblclick, blur, notNewNode is true
              if (that.startText !== d.text || d.id === that.nodes.length - 1) {
                that.nodeToChange = d;
                storeToHistory();
              }

              that.startText = null;
              that.nodeToChange = null;

              that.textInputCircle = null;
            })
            .on("keydown", function() {
              if (d3.event.keyCode === 13 && !d3.event.shiftKey) {
                d3.event.preventDefault();
              }
            })
            .on("keyup", function() {
              if (d3.event.keyCode === 13 && !d3.event.shiftKey) {
                this.blur();
              } else {
                var node = d3.select(this).node();
                // note, d.text is referring to the d in dblclick, d in g, d in text, from that.nodes
                var nodeHTML = d3.select(this).node().innerHTML;

                nodeHTML = nodeHTML.slice(3, nodeHTML.length - 4);

                if (
                  nodeHTML.substring(nodeHTML.length - 4, nodeHTML.length) ===
                  "<br>"
                ) {
                  nodeHTML = nodeHTML.slice(0, nodeHTML.length - 4);
                }

                var textArr = nodeHTML.split("<br>");
                d.text = textArr;

                restart();
              }
            });

          paragraph.node().focus();

          //restart();
        })
        .on("mouseover", function(d) {
          if (!d3.event.ctrlKey || !that.linkModeActivated) return;
          if (!that.mousedownNode || d === that.mousedownNode) return;
          // enlarge target node
          d3.select(this).attr("transform", "scale(1.1)");
        })
        .on("mouseout", function(d) {
          if (!that.mousedownNode || d === that.mousedownNode) return;
          // unenlarge target node
          d3.select(this).attr("transform", "");
        })
        .on("mousedown", d => {
          // select node
          that.mousedownNode = d;
          that.selectedNode =
            that.mousedownNode === that.selectedNode
              ? null
              : that.mousedownNode;
          that.selectedLink = null;
        })
        .on("mouseup", function(d) {
          if (!that.mousedownNode) return;

          svg.call(
            d3
              .zoom()
              .scaleExtent([0.1, 4])
              .on("zoom", function() {
                container.attr("transform", d3.event.transform);
              })
          );
          // needed by FF
          dragLine.classed("hidden", true).style("marker-end", "");

          // check for drag-to-self
          that.mouseupNode = d;
          if (that.mouseupNode === that.mousedownNode) {
            resetMouseVars();
            return;
          }

          // unenlarge target node
          d3.select(this).attr("transform", "");

          // add link to graph (update if exists)
          // NB: that.links are strictly source < target; arrows separately specified by booleans
          const isRight = that.mousedownNode.id < that.mouseupNode.id;
          const source = that.mousedownNode;
          const target = that.mouseupNode;

          that.links.push({ source, target });

          storeToHistory();
          // select new link

          that.selectedNode = null;
          that.mousedownNode = null;

          restart();
        });
      circle = g.merge(circle);

      // set the graph in motion
      that.force
        .nodes(that.nodes)
        .force("link")
        .links(that.links)
        .distance(250);

      that.force.alphaTarget(0.3).restart();
    }

    function click() {
      if (d3.event.ctrlKey) {
        // because :active only works in WebKit?
        svg.classed("active", true);

        // insert new node at point
        var point = d3.mouse(this);

        var transform = d3.zoomTransform(container.node());
        point = transform.invert(point);

        const node = {
          id: that.nodes.length,
          width: 150,
          height: 40,
          x: point[0],
          y: point[1],
          text: [""]
        };
        that.nodes.push(node);
        //storeToHistory();
        //console.log(container.attr("transform"));
        //looks like: translate(100,50) scale(0.5)

        that.previousTransform = container.attr("transform");
        that.updateEntire();

        d3.selectAll("rect")
          .filter(function(d, i, list) {
            return i === list.length - 1;
          })
          .dispatch("dblclick");
      }
    }
    function huh() {
      that.isCentering = !that.isCentering;
      //console.log(that.isCentering);
      if (that.isCentering) {
        that.force
          .nodes(that.nodes)
          .force("link")
          .links(that.links)
          .distance(250);

        that.force.alphaTarget(0.3).restart();
        that.force
          .force("x", d3.forceX(500))
          .force("y", d3.forceY(500))
          .restart();
      } else {
        that.force.force("x", null).force("y", null);
      }

      //  console.log("force", that.force);
    }

    function mousedown() {}
    function mousemove() {
      if (!that.mousedownNode) return;

      // update drag line
      if (d3.event.ctrlKey || that.linkModeActivated) {
        //  console.log("in svg's mousemove");
        dragLine
          .classed("hidden", false)
          .style("marker-end", "url(#end-arrow)");
        //console.log("this?", this, d3.mouse(this), d3.mouse(container.node()));

        var transform = d3.zoomTransform(container.node());
        var xy1 = transform.invert(d3.mouse(svg.node()));
        dragLine.attr(
          "d",
          `M${that.mousedownNode.x + that.mousedownNode.width / 2},${that
            .mousedownNode.y +
            that.mousedownNode.height / 2}L${xy1[0]},${xy1[1]}`
        );
      }
    }

    function mouseup() {
      if (that.mousedownNode) {
        // hide drag line
        dragLine.classed("hidden", true).style("marker-end", "");
      }

      // because :active only works in WebKit?
      svg.classed("active", false);

      resetMouseVars();
    }

    function splicelinksForNode(node) {
      const toSplice = that.links.filter(
        l => l.source === node || l.target === node
      );
      for (const l of toSplice) {
        that.links.splice(that.links.indexOf(l), 1);
      }
    }

    // only respond once per keydown
    let lastKeyDown = -1;

    function keydown() {
      if (d3.event.ctrlKey) {
        if (
          (d3.event.keyCode === 17 && d3.event.shiftKey) ||
          d3.event.keyCode === 89
        ) {
          // console.log("redo");
          if (that.historyStep !== that.history.length - 1) {
            that.historyStep += 1;

            that.nodes = that.history[that.historyStep].nodes;

            //apply the text
            if (that.history[that.historyStep].nodeToChangeID !== -1) {
              console.log(
                "node whose value we are changing",
                that.history[that.historyStep].nodeToChangeID
              );
              that.nodes.map(eachNode => {
                if (
                  eachNode.id === that.history[that.historyStep].nodeToChangeID
                ) {
                  console.log("matched", eachNode);
                  eachNode.text = JSON.parse(
                    JSON.stringify(that.history[that.historyStep].texts.redoTo)
                  );
                }
              });
            }

            that.links = [...that.history[that.historyStep].links];
            console.log(
              "entire history",
              that.history,
              "step: ",
              that.historyStep
            );
            restart();
          }
        } else if (d3.event.keyCode === 90) {
          /*
          //UNDO
          if (that.historyStep !== 0) {
            that.historyStep -= 1;

            that.nodes = that.history[that.historyStep].nodes;

            //apply the text
            if (that.history[that.historyStep + 1].nodeToChangeID !== -1) {
              console.log(
                "node whose value we are changing",
                that.history[that.historyStep + 1].nodeToChangeID
              );
              that.nodes.map(eachNode => {
                if (
                  eachNode.id ===
                  that.history[that.historyStep + 1].nodeToChangeID
                ) {
                  console.log("matched", eachNode);
                  eachNode.text = JSON.parse(
                    JSON.stringify(
                      that.history[that.historyStep + 1].texts.undoTo
                    )
                  );
                }
              });
            }

            that.links = [...that.history[that.historyStep].links];
            console.log(
              "entire history",
              that.history,
              "step: ",
              that.historyStep
            );
            restart();
          }
*/

          var rand = Math.floor(Math.random() * 2);
          if (rand === 0) {
            //try randomly removing a node
            that.nodes = that.nodes.filter(function(value, index) {
              return value.id !== 0;
            });
restart()
          } else {
            //try randomly adding a link
          }
        }

        d3.select("#linkPic").attr("src", link_purple);
      }
      //console.log("uhhh");
      if (!that.selectedNode && !that.selectedLink) return;

      switch (d3.event.keyCode) {
        case 8: // backspace
        case 46: // delete
          if (that.selectedNode) {
            that.nodes.splice(that.nodes.indexOf(that.selectedNode), 1);
            splicelinksForNode(that.selectedNode);
          } else if (that.selectedLink) {
            that.links.splice(that.links.indexOf(that.selectedLink), 1);
          }
          that.selectedLink = null;
          that.selectedNode = null;

          restart();
          storeToHistory();
          break;
        case 66: // Bf
          if (that.selectedLink) {
            // set link direction to both left and right
            that.selectedLink.left = true;
            that.selectedLink.right = true;
          }

          restart();
          storeToHistory();
          break;
        case 76: // L
          if (that.selectedLink) {
            // set link direction to left only
            that.selectedLink.left = true;
            that.selectedLink.right = false;
          }
          restart();
          break;
        case 82: // R
          if (that.selectedNode) {
            // toggle node reflexivity
            that.selectedNode.reflexive = !that.selectedNode.reflexive;
          } else if (that.selectedLink) {
            // set link direction to right only
            that.selectedLink.left = false;
            that.selectedLink.right = true;
          }
          restart();
          break;
      }
    }

    function keyup() {
      lastKeyDown = -1;

      // ctrl
      if (d3.event.keyCode === 17 && !that.linkModeActivated) {
        d3.select("#linkPic").attr("src", link);
      }
    }

    function resize() {
      svg
        .style("width", 0.75 * window.innerWidth)
        .style("height", window.innerHeight);
    }
  }

  onTxtToNode = txt => {
    const node = {
      id: this.nodes.length,
      width: 150,
      height: 40,
      text: txt.split("\n"),
      x: 100,
      y: 100
    };
    this.nodes.push(node);

    this.previousTransform = d3.select("g.gContainer").attr("transform");
    this.updateEntire();
  };
  render() {
    return (
      <div id="editorsContainer" className="">
        <PageContainer onTxtToNode={this.onTxtToNode} />
      </div>
    );
  }
}
export default GraphEditor;

import React, { Component } from "react";
import * as d3 from "d3";
import { select, event } from "d3-selection";
import "./GraphEditor.css";
import "d3-selection-multi";
import link from "./svgs/network.svg";
import link_purple from "./svgs/network_purple.svg";
import add from "./svgs/thin-add-button.svg";
import focus from "./svgs/crosshair.svg";

import PageContainer from "./PageContainer.js";

// set up svg for D3
const initialNodes = [
  {
    id: 0,
    width: 50,
    height: 40,
    text: ["here"],
    opacity: 1,
    x: 750,
    y: 200
  },
  {
    id: 1,
    width: 50,
    height: 40,
    text: ["start"],
    opacity: 1,
    x: 600,
    y: 200
  },
  {
    id: 2,
    width: 50,
    height: 40,
    text: ["hi"],
    x: 300,
    y: 200
  }
];
const initialLinks = [
  {
    source: initialNodes[1],
    target: initialNodes[2]
  },

  {
    source: initialNodes[2],
    target: initialNodes[0]
  }
];

class GraphEditor extends Component {
  constructor(props) {
    super(props);

    this.nodes = initialNodes;
    this.links = initialLinks;
    this.lastNodeId = 2;

    this.selectedNode = null;
    this.selectedLink = null;
    this.mousedownLink = null;
    this.mousedownNode = null;
    this.mouseupNode = null;

    this.linkModeActivated = false;
    this.isCentering = false;

    this.force = null;
    this.startText = null;
    this.history = [{ type: null, undoAction: null, redoAction: null }];
    this.txtHistory = [];
    this.historyStep = 0;
    this.previousTransform = null;
  }

  updateEntire() {
    d3.selectAll("svg").remove("*");
    d3.selectAll(".GraphEditorContainer")

      .selectAll("svg")
      .remove("*");

    this.force.stop();
    this.componentDidMount();
    this.force.restart();
  }

  componentDidMount() {
    var that = this;

    var GraphEditor = d3.select("div#editorsContainer");
    var svgContainer = GraphEditor.append("div").attr(
      "class",
      "GraphEditorContainer"
    );

    //d3.select("#addPic").on("click", addNewNode);
    d3.select("#focusPic").on("click", huh);
    d3.select("#linkPic").on("click", function() {
      var current = d3.select(this);
      if (current.attr("src") === link_purple) {
        that.linkModeActivated = false;
        current.attr("src", link);
      } else {
        current.attr("src", link_purple);
        that.linkModeActivated = true;
      }
    });

    const colors = d3.scaleOrdinal(d3.schemeCategory10);

    that.force = d3
      .forceSimulation()
      .force("link", d3.forceLink().id(d => d.id))
      .force("charge", d3.forceManyBody().strength(-5))

      .on("tick", tick);

    const svg = d3
      .select(".GraphEditorContainer")
      .append("svg")

      .style("width", window.innerWidth * 0.75)
      .attr("height", window.innerHeight)
      .style("float", "left");
    // define arrow markers for graph that.link
    svg
      .append("svg:defs")
      .append("svg:marker")
      .attr("id", "end-arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 6)
      .attr("markerWidth", 3)
      .attr("markerHeight", 3)
      .attr("orient", "auto")
      .append("svg:path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#000");

    svg
      .append("svg:defs")
      .append("svg:marker")
      .attr("id", "start-arrow")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 4)
      .attr("markerWidth", 3)
      .attr("markerHeight", 3)
      .attr("orient", "auto")
      .append("svg:path")
      .attr("d", "M10,-5L0,0L10,5")
      .attr("fill", "#000");

    // line displayed when dragging new nodes

    const drag = d3
      .drag()
      .filter(function() {
        if (that.linkModeActivated) {
          svg
            .on(".zoom", null)
            .on("mousedown.zoom", null)
            .on("touchstart.zoom", null)
            .on("touchmove.zoom", null)
            .on("touchend.zoom", null);
        }

        return !that.linkModeActivated && !d3.event.ctrlKey;
      })
      .on("start", d => {
        if (!d3.event.active) that.force.alphaTarget(0.3).restart();

        d.fx = d.x;
        d.fy = d.y;
      })
      .on("drag", d => {
        if (!that.linkModeActivated) {
          d.fx = d3.event.x;
          d.fy = d3.event.y;
        } else {
          dragLine
            .classed("hidden", false)
            .style("marker-end", "url(#end-arrow)");
          dragLine.attr(
            "d",
            `M${that.mousedownNode.x + that.mousedownNode.width / 2},${that
              .mousedownNode.y +
              that.mousedownNode.height / 2}L${d3.mouse(svg.node())[0]},${
              d3.mouse(svg.node())[1]
            }`
          );
        }
      })
      .on("end", d => {
        if (that.linkModeActivated) {
          dragLine.classed("hidden", true);
        }
        if (!d3.event.active) that.force.alphaTarget(0);

        d.fx = null;
        d.fy = null;
        resetMouseVars();
      });
    var container = svg
      .on("mousedown", mousedown)
      .on("mousemove", mousemove)
      .on("mouseup", mouseup)
      .on("keydown", keydown)
      .on("click", click)

      .append("svg:g")
      .attr("class", "gContainer")
      .attrs({
        //TODO
        //transform: previous transform
        transform: that.previousTransform ? that.previousTransform : null
      });

    const dragLine = container
      .append("svg:path")
      .attr("class", "link dragline hidden")
      .attr("d", "M0,0L0,0")
      .classed("hidden", true);

    // handles to link and node element groups
    let path = container.append("svg:g").selectAll("path");
    let circle = container
      .append("svg:g")
      .selectAll("g")
      .attr("class", "rectTextGroup");
    let textBox = container.append("foreignObject");
    // app starts here
    var zoom = d3.zoom().on("zoom", function() {
      container.attr("transform", d3.event.transform);
    });

    svg.call(zoom).on("dblclick.zoom", null);

    if (that.previousTransform) {
      var arr = that.previousTransform.split("(");

      var translate = arr[1].split(")")[0],
        scale = arr[2].split(")")[0];

      svg.call(
        zoom.transform,
        d3.zoomIdentity
          .translate(
            translate.substring(0, translate.indexOf(",")),
            translate.substring(translate.indexOf(",") + 1)
          )
          .scale(scale)
      );
    }

    //.attr("transform", that.previousTransform);

    d3.select(window)
      .on("keydown", keydown)
      .on("keyup", keyup)
      .on("resize", resize);
    restart();

    function resetMouseVars() {
      that.mousedownNode = null;
      that.mouseupNode = null;
      that.mousedownLink = null;
    }
    // update force layout (called automatically each iteration)
    function tick() {
      // draw directed edges with proper padding from node centers

      path.attr("d", d => {
        //console.log("force", that.force.nodes());
        var dy = d.target.y - d.source.y;
        var dx = d.target.x - d.source.x;
        var theta = Math.atan2(-dy, dx);
        theta += Math.PI;
        let angle = (theta * Math.PI) / 180;
        const shiftXBy = 0;
        return `M${d.source.x + d.source.width / 2},${d.source.y +
          d.source.height / 2}L${d.target.x + d.target.width / 2},${d.target.y +
          d.target.height / 2}`;
      });

      circle.attr("transform", d => {
        if (that.textInputCircle)
          if (d.id === that.textInputCircle.id) {
            that.textInputCircle.x = d.x;
            that.textInputCircle.y = d.y;
          }

        return `translate(${d.x},${d.y})`;
      });

      if (textBox.attr("x")) {
        //warning, chance 25 to something else, this is calculated with 50 / 2
        textBox
          .attr("x", that.textInputCircle.x + 25)
          .attr("y", that.textInputCircle.y);
      }
    }
    // update graph (called when needed)
    function storeToHistory(newStep) {
      var type = newStep.type;
      var undoAction = newStep.undoAction;
      var redoAction = newStep.redoAction;

      var previousStepRedoAction = reverseOperation(newStep);

      that.history[that.historyStep].redoAction = previousStepRedoAction;
      that.history = that.history.slice(0, that.historyStep + 1);

      var pushToHistory = {
        type: type,
        undoAction: undoAction,
        redoAction: redoAction
      };
      that.history = that.history.concat([newStep]);

      that.historyStep += 1;

      console.log("entire history", that.history, "step: ", that.historyStep);
    }

function reverseOperation(operation){
  if(operation.type === "add_node"){
//return add node operation
var undoAction = operation.undoAction;
var redoAction


}

}

    function restart() {
      // path (link) group

      d3.selectAll("rect.node").remove();
      d3.selectAll("text").remove();
      //console.log("restarted");
      //JOIN DATA
      path = path.data(that.links);

      // update existing that.links
      path
        .classed("selected", d => d === that.selectedLink)
        .style("marker-end", "url(#end-arrow)");

      // EXIT
      path.exit().remove();

      // UPDATE
      path = path
        .enter()
        .append("svg:path")
        .attr("class", "link")
        .classed("selected", d => d === that.selectedLink)
        .style("marker-end", "url(#end-arrow)")
        .on("mousedown", d => {
          if (d3.event.ctrlKey || that.linkModeActivated) return;

          // select link
          that.mousedownLink = d;
          that.selectedLink =
            that.mousedownLink === that.selectedLink
              ? null
              : that.mousedownLink;
          that.selectedNode = null;
          restart();
        })
        .merge(path);

      // bind data
      // svg => g => g => {circle, text}
      let g = circle.data(that.nodes, d => d.id);
      g.exit().remove();
      g = g
        .enter()
        .append("svg:g")
        .attr("class", "rectTextGroup")
        .merge(g)
        .call(drag);

      g.on("mouseup", function() {});

      //d3.selectAll("rect").remove();
      //d3.selectAll("text").remove();

      var rect = g.append("svg:rect");

      //console.log("rect", rect);

      //render text's text so we have bboxWidth,

      var textContainers = g.append("svg:g").attr("class", "textContainer");

      textContainers

        .attr("opacity", d => d.opacity)
        //.attr("text-anchor", "middle")
        .attr("dy", function(d) {
          var nwords = d.text.length;
          return "-" + (nwords - 1) * 12;
        })
        .each(function(d, ind) {
          //after appending the tspan elements
          //we get access to widthArray
          var nwords = d.text.length;
          for (var i = 0; i < nwords; i++) {
            var tspan = d3
              .select(this)
              .append("text")
              .html(function(d) {
                var a = d.text[i];
                while (a.includes(" ")) {
                  a = a.replace(" ", "&nbsp;");
                }
                return a;
              });

            tspan.call(() => {
              var bboxWidth = d3
                .select(this)
                .node()
                .getBBox().width;

              that.textInputCircle = {
                ...that.textInputCircle,
                goodX: (d.width - bboxWidth) / 2
              };
            });

            if (i > 0) tspan.attr("y", 15 * i);
          }

          var eachTextHeight = d3
            .select(this)
            .select("text")
            .node()
            .getBBox().height;
          var textGroup = d3.select(this).selectAll("text");
          var widthArray = [];
          textGroup.each(function() {
            widthArray.push(
              d3
                .select(this)
                .node()
                .getBBox().width
            );
          });
          d.width = Math.max(...widthArray) + 50;

          d.height = d.text.length * eachTextHeight + 25;

          //console.log("width array for text group num " + ind, widthArray);
        })
        .style("transform", function(d) {
          var bboxWidth = d3
            .select(this)
            .node()
            .getBBox().width;

          var bboxHeight = d3
            .select(this)
            .node()
            .getBBox().height;
          var toShiftX = 25;
          var toShiftY = (d.height - bboxHeight) / 2 + 12.5;
          return "translate(" + toShiftX + "px, " + toShiftY + "px)";
        });

      rect
        .attr("class", "node")
        .attr("rx", 6)
        .attr("ry", 6)
        .attrs({
          width: d => d.width,
          height: d => d.height
        })
        .style("fill", d =>
          d === that.selectedNode
            ? d3
                .rgb(colors(d.id))
                .brighter()
                .toString()
            : colors(d.id)
        )
        .style("stroke", "black")
        .on("click", function(d) {
          if (
            d3.select(this).style("fill") === d3.rgb(colors(d.id)).toString()
          ) {
            d3.select(this).style("fill", d =>
              d3
                .rgb(colors(d.id))
                .brighter()
                .toString()
            );
          } else {
            that.selectedNode = null;
            d3.select(this).style("fill", d => d3.rgb(colors(d.id)).toString());
          }
        })
        .on("dblclick", function(d) {
          svg.on(".zoom", null);

          that.startText = d.text;
          that.nodes.map(eachNode => {
            if (eachNode.id === d.id) {
              eachNode.opacity = 0;
              restart();
            }
          });
          that.textInputCircle = d;
          // warning: please replac window.innerWidth
          textBox = textBox
            .attr("x", function(d) {
              return 10;
            })
            .attr("y", d.y)
            .attr("width", window.innerWidth / 2)
            .attr("height", window.innerHeight);
          var paragraph = textBox
            .append("xhtml:p")
            .html(function() {
              function textArrToHTML(textArr) {
                //["hi my name is", "andrew chen"] to <p>hi my name is<br>andrew chen</p>
                var initialHTML = "<p>";
                for (var i = 0; i < textArr.length; i++) {
                  if (textArr[i] === "") {
                    initialHTML += "<br>";
                  } else initialHTML += textArr[i];

                  if (i !== textArr.length - 1 && textArr[i] !== "") {
                    initialHTML += "<br>";
                  }
                }
                return initialHTML + "</p>";
              }
              var textArr = d.text;
              var html = textArrToHTML(textArr);

              return html;
            })
            .attr("contentEditable", "true")
            //warning: changing to window.innerWidth to prevent some dude spamming shift enter or extra long node?
            .attr("width", window.innerWidth / 2)
            .style("width", window.innerWidth / 2)
            .style("outline", 0)
            .style("font", "12px sans-serif")
            .style("display", "block");

          paragraph
            .on("blur", function() {
              svg.call(
                d3
                  .zoom()
                  .scaleExtent([0.1, 4])
                  .on("zoom", function() {
                    container.attr("transform", d3.event.transform);
                  })
              );
              d3.selectAll("foreignObject").remove();
              textBox = container.append("foreignObject");

              that.nodes.map(eachNode => {
                if (eachNode.id === that.textInputCircle.id) {
                  eachNode.opacity = 1;
                  restart();
                }
              });

              /*
              var oldNodes = that.history[that.historyStep].nodes;

              var matchedNode = oldNodes.filter(eachNode => {
                return eachNode.id === d.id;
              });

              //TODO: if text isn't the same or the node is brand new, store to history
              //on add new node, notNewNode is false
              //on dblclick, blur, notNewNode is true
              if (that.startText !== d.text || d.id === that.nodes.length - 1) {
                that.nodeToChange = d;
                //storeToHistory();
              }

*/
              that.startText = null;
              that.nodeToChange = null;

              that.textInputCircle = null;
            })
            .on("keydown", function() {
              if (d3.event.keyCode === 13 && !d3.event.shiftKey) {
                d3.event.preventDefault();
              }
            })
            .on("keyup", function() {
              if (d3.event.keyCode === 13 && !d3.event.shiftKey) {
                this.blur();
              } else {
                var node = d3.select(this).node();
                // note, d.text is referring to the d in dblclick, d in g, d in text, from that.nodes
                var nodeHTML = d3.select(this).node().innerHTML;

                nodeHTML = nodeHTML.slice(3, nodeHTML.length - 4);

                if (
                  nodeHTML.substring(nodeHTML.length - 4, nodeHTML.length) ===
                  "<br>"
                ) {
                  nodeHTML = nodeHTML.slice(0, nodeHTML.length - 4);
                }

                var textArr = nodeHTML.split("<br>");
                d.text = textArr;

                restart();
              }
            });

          paragraph.node().focus();

          //restart();
        })
        .on("mouseover", function(d) {
          if (!d3.event.ctrlKey || !that.linkModeActivated) return;
          if (!that.mousedownNode || d === that.mousedownNode) return;
          // enlarge target node
          d3.select(this).attr("transform", "scale(1.1)");
        })
        .on("mouseout", function(d) {
          if (!that.mousedownNode || d === that.mousedownNode) return;
          // unenlarge target node
          d3.select(this).attr("transform", "");
        })
        .on("mousedown", d => {
          // select node
          that.mousedownNode = d;
          that.selectedNode =
            that.mousedownNode === that.selectedNode
              ? null
              : that.mousedownNode;
          that.selectedLink = null;
        })
        .on("mouseup", function(d) {
          if (!that.mousedownNode) return;

          svg.call(
            d3
              .zoom()
              .scaleExtent([0.1, 4])
              .on("zoom", function() {
                container.attr("transform", d3.event.transform);
              })
          );
          // needed by FF
          dragLine.classed("hidden", true).style("marker-end", "");

          // check for drag-to-self
          that.mouseupNode = d;
          if (that.mouseupNode === that.mousedownNode) {
            resetMouseVars();
            return;
          }

          // unenlarge target node
          d3.select(this).attr("transform", "");

          // add link to graph (update if exists)
          // NB: that.links are strictly source < target; arrows separately specified by booleans
          const isRight = that.mousedownNode.id < that.mouseupNode.id;
          const source = that.mousedownNode;
          const target = that.mouseupNode;

          that.links.push({ source, target });

          storeToHistory();
          // select new link

          that.selectedNode = null;
          that.mousedownNode = null;

          restart();
        });
      circle = g.merge(circle);

      // set the graph in motion
      that.force
        .nodes(that.nodes)
        .force("link")
        .links(that.links)
        .distance(250);

      that.force.alphaTarget(0.3).restart();
    }

    function click() {
      if (d3.event.ctrlKey) {
        // because :active only works in WebKit?
        svg.classed("active", true);

        // insert new node at point
        var point = d3.mouse(this);

        var transform = d3.zoomTransform(container.node());
        point = transform.invert(point);

        const node = {
          id: that.nodes.length,
          width: 150,
          height: 40,
          x: point[0],
          y: point[1],
          text: [""]
        };
        that.nodes.push(node);
        storeToHistory({
          type: "add_node",
          undoAction: "remove_node" + node.id,
          redoAction: null, object: node
        });
        //console.log(container.attr("transform"));
        //looks like: translate(100,50) scale(0.5)

        that.previousTransform = container.attr("transform");
        that.updateEntire();

        d3.selectAll("rect")
          .filter(function(d, i, list) {
            return i === list.length - 1;
          })
          .dispatch("dblclick");
      }
    }
    function huh() {
      that.isCentering = !that.isCentering;
      //console.log(that.isCentering);
      if (that.isCentering) {
        that.force
          .nodes(that.nodes)
          .force("link")
          .links(that.links)
          .distance(250);

        that.force.alphaTarget(0.3).restart();
        that.force
          .force("x", d3.forceX(500))
          .force("y", d3.forceY(500))
          .restart();
      } else {
        that.force.force("x", null).force("y", null);
      }

      //  console.log("force", that.force);
    }

    function mousedown() {}
    function mousemove() {
      if (!that.mousedownNode) return;

      // update drag line
      if (d3.event.ctrlKey || that.linkModeActivated) {
        //  console.log("in svg's mousemove");
        dragLine
          .classed("hidden", false)
          .style("marker-end", "url(#end-arrow)");
        //console.log("this?", this, d3.mouse(this), d3.mouse(container.node()));

        var transform = d3.zoomTransform(container.node());
        var xy1 = transform.invert(d3.mouse(svg.node()));
        dragLine.attr(
          "d",
          `M${that.mousedownNode.x + that.mousedownNode.width / 2},${that
            .mousedownNode.y +
            that.mousedownNode.height / 2}L${xy1[0]},${xy1[1]}`
        );
      }
    }

    function mouseup() {
      if (that.mousedownNode) {
        // hide drag line
        dragLine.classed("hidden", true).style("marker-end", "");
      }

      // because :active only works in WebKit?
      svg.classed("active", false);

      resetMouseVars();
    }

    function splicelinksForNode(node) {
      const toSplice = that.links.filter(
        l => l.source === node || l.target === node
      );
      for (const l of toSplice) {
        that.links.splice(that.links.indexOf(l), 1);
      }
    }

    // only respond once per keydown
    let lastKeyDown = -1;

    function keydown() {
      if (d3.event.ctrlKey) {
        if (
          (d3.event.keyCode === 17 && d3.event.shiftKey) ||
          d3.event.keyCode === 89
        ) {
          //REDO
          if (that.historyStep !== that.history.length - 1) {
            execOperation(that.history[that.historyStep].redoAction);
            that.historyStep += 1;

            restart();
          }
        } else if (d3.event.keyCode === 90) {
          if (that.historyStep !== 0) {
            execOperation(that.history[that.historyStep].undoAction);
            that.historyStep -= 1;
            restart();
          }
          /*
          //UNDO
          if (that.historyStep !== 0) {
            that.historyStep -= 1;

            that.nodes = that.history[that.historyStep].nodes;

            //apply the text
            if (that.history[that.historyStep + 1].nodeToChangeID !== -1) {
              console.log(
                "node whose value we are changing",
                that.history[that.historyStep + 1].nodeToChangeID
              );
              that.nodes.map(eachNode => {
                if (
                  eachNode.id ===
                  that.history[that.historyStep + 1].nodeToChangeID
                ) {
                  console.log("matched", eachNode);
                  eachNode.text = JSON.parse(
                    JSON.stringify(
                      that.history[that.historyStep + 1].texts.undoAction
                    )
                  );
                }
              });
            }

            that.links = [...that.history[that.historyStep].links];
            console.log(
              "entire history",
              that.history,
              "step: ",
              that.historyStep
            );
            restart();
          }
*/
        }

        d3.select("#linkPic").attr("src", link_purple);
      }
      //console.log("uhhh");
      if (!that.selectedNode && !that.selectedLink) return;

      switch (d3.event.keyCode) {
        case 8: // backspace
        case 46: // delete
          if (that.selectedNode) {
            that.nodes.splice(that.nodes.indexOf(that.selectedNode), 1);
            splicelinksForNode(that.selectedNode);
          } else if (that.selectedLink) {
            that.links.splice(that.links.indexOf(that.selectedLink), 1);
          }
          that.selectedLink = null;
          that.selectedNode = null;

          restart();
          storeToHistory();
          break;
        case 66: // Bf
          if (that.selectedLink) {
            // set link direction to both left and right
            that.selectedLink.left = true;
            that.selectedLink.right = true;
          }

          restart();
          storeToHistory();
          break;
        case 76: // L
          if (that.selectedLink) {
            // set link direction to left only
            that.selectedLink.left = true;
            that.selectedLink.right = false;
          }
          restart();
          break;
        case 82: // R
          if (that.selectedNode) {
            // toggle node reflexivity
            that.selectedNode.reflexive = !that.selectedNode.reflexive;
          } else if (that.selectedLink) {
            // set link direction to right only
            that.selectedLink.left = false;
            that.selectedLink.right = true;
          }
          restart();
          break;
      }
    }

    function execOperation(operation) {
      var toPerform = operation;
      console.log(toPerform);
      if (toPerform.includes("remove_node")) {
        console.log("will remove node with id of", toPerform.substring(11));
        var id = parseInt(toPerform.substring(11));
        that.nodes = that.nodes.filter(eachNode => {
          return eachNode.id !== id;
        });
      } else if (toPerform.includes("add_node")) {
        console.log("will add node with id of", toPerform.substring(7));
        var id = parseInt(toPerform.substring(7));
        that.nodes = that.nodes.filter(eachNode => {
          return eachNode.id !== id;
        });
      }
    }

    function keyup() {
      lastKeyDown = -1;

      // ctrl
      if (d3.event.keyCode === 17 && !that.linkModeActivated) {
        d3.select("#linkPic").attr("src", link);
      }
    }

    function resize() {
      svg
        .style("width", 0.75 * window.innerWidth)
        .style("height", window.innerHeight);
    }
  }

  onTxtToNode = txt => {
    const node = {
      id: this.nodes.length,
      width: 150,
      height: 40,
      text: txt.split("\n"),
      x: 100,
      y: 100
    };
    this.nodes.push(node);

    this.previousTransform = d3.select("g.gContainer").attr("transform");
    this.updateEntire();
  };
  render() {
    return (
      <div id="editorsContainer" className="">
        <PageContainer onTxtToNode={this.onTxtToNode} />
      </div>
    );
  }
}
export default GraphEditor;
